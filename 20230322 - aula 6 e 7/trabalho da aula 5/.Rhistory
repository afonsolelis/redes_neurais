# Lista para armazenar os modelos treinados
trained_models <- list()
# Treinar e testar o modelo em uma janela deslizante de 10 em 10 com etapa de 1
for (i in 1:(nrow(x) - tam_janela + 1)) {
#cat("Testando janela", i, "até", i + tam_janela - 1, "\n")
model <- train_test_mlp(x, y, test_start = i, test_end = i + tam_janela - 1)
#summary(model)
trained_models[[length(trained_models) + 1]] <- model
}
bd <- read.table("ibovespa_3.csv", header = TRUE, sep = ";")
x <- bd[, 1]
x <- normalizeData(x, type = "0_1")
tam_janela <- 10
nro_padroes <- trunc(dim(x)[1] / tam_janela)
dataset <- matrix(x, nrow = tam_janela, ncol = nro_padroes)
dataset <- t(dataset)
plot(dataset[, tam_janela])
# Column bind the data into one variable
x <- dataset[, 1:tam_janela - 1]
y <- dataset[, tam_janela]
# Função personalizada para dividir os dados de treinamento e teste com base no índice
split_data_by_index <- function(inputs, targets, test_indices) {
inputs_test <- inputs[test_indices,]
targets_test <- targets[test_indices]
inputs_train <- inputs[-test_indices,]
targets_train <- targets[-test_indices]
return(list(inputsTrain = inputs_train, targetsTrain = targets_train,
inputsTest = inputs_test, targetsTest = targets_test))
}
# Função para treinar e testar o modelo
train_test_mlp <- function(inputs, targets, test_start, test_end) {
data <- split_data_by_index(inputs, targets, test_indices = c(test_start:test_end))
model <- mlp(data$inputsTrain, data$targetsTrain,
size = c(2),
learnFuncParams = c(0.9),
maxit = 10,
learnFunc = "Std_Backpropagation",
hiddenActFunc = "Act_Logistic",
inputsTest = as.data.frame(data$inputsTest),
targetsTest = data$targetsTest,
linOut = TRUE
)
return(model)
}
# Função para plotar os resultados
plot_results <- function(model, data) {
# plot dados de treinamento
predictions <- predict(model, data$inputsTrain)
plot(seq(1, length(data$targetsTrain)), data$targetsTrain, xlab = "x", ylab = "y", type = "p", col = "blue", pch = 1, cex = 1.5)
points(predictions, type = "p", col = "red", pch = 16)
# plot dados de teste
predictions <- predict(model, as.data.frame(data$inputsTest))
plot(seq(1, length(data$targetsTest)), data$targetsTest, xlab = "x", ylab = "y", type = "p", col = "blue", pch = 1, cex = 1.5)
points(predictions, type = "p", col = "red", pch = 16)
}
# Lista para armazenar os modelos treinados
trained_models <- list()
# Treinar e testar o modelo em uma janela deslizante de 10 em 10 com etapa de 1
for (i in 1:(nrow(x) - tam_janela + 1)) {
#cat("Testando janela", i, "até", i + tam_janela - 1, "\n")
model <- train_test_mlp(x, y, test_start = i, test_end = i + tam_janela - 1)
#summary(model)
trained_models[[length(trained_models) + 1]] <- model
}
# Função para fazer previsões com todos os modelos treinados
predict_all_models <- function(models, inputs) {
all_predictions <- c()
for (i in 1:length(models)) {
model <- models[[i]]
predictions <- predict(model, inputs[i:(i + tam_janela - 2), ])
all_predictions <- c(all_predictions, predictions[1])
}
return(all_predictions)
}
# Fazer previsões com todos os modelos treinados
all_predictions <- predict_all_models(trained_models, x)
# Plot da série temporal completa junto com as previsões
plot(seq(1, length(y)), y, xlab = "x", ylab = "y", type = "p", col = "blue", pch = 1, cex = 1.5)
points(seq(1, length(all_predictions)), all_predictions, type = "p", col = "red", pch = 16)
knitr::opts_chunk$set(echo = TRUE)
#install.packages("RSNNS")
library("RSNNS")
bd <- read.table("ibovespa_3.csv", header = TRUE, sep = ";")
x <- bd[, 1]
x <- normalizeData(x, type = "0_1")
plot(x)
bd <- read.table("ibovespa_3.csv", header = TRUE, sep = ";")
x <- bd[, 1]
x <- normalizeData(x, type = "0_1")
tam_janela <- 5
nro_padroes <- trunc(dim(x)[1] / tam_janela)
dataset <- matrix(x, nrow = tam_janela, ncol = nro_padroes)
dataset <- t(dataset)
plot(dataset[, tam_janela])
# Column bind the data into one variable
x <- dataset[, 1:tam_janela - 1]
y <- dataset[, tam_janela]
# Função personalizada para dividir os dados de treinamento e teste com base no índice
split_data_by_index <- function(inputs, targets, test_indices) {
inputs_test <- inputs[test_indices,]
targets_test <- targets[test_indices]
inputs_train <- inputs[-test_indices,]
targets_train <- targets[-test_indices]
return(list(inputsTrain = inputs_train, targetsTrain = targets_train,
inputsTest = inputs_test, targetsTest = targets_test))
}
# Função para treinar e testar o modelo
train_test_mlp <- function(inputs, targets, test_start, test_end) {
data <- split_data_by_index(inputs, targets, test_indices = c(test_start:test_end))
model <- mlp(data$inputsTrain, data$targetsTrain,
size = c(2),
learnFuncParams = c(0.9),
maxit = 10,
learnFunc = "Std_Backpropagation",
hiddenActFunc = "Act_Logistic",
inputsTest = as.data.frame(data$inputsTest),
targetsTest = data$targetsTest,
linOut = TRUE
)
return(model)
}
# Função para plotar os resultados
plot_results <- function(model, data) {
# plot dados de treinamento
predictions <- predict(model, data$inputsTrain)
plot(seq(1, length(data$targetsTrain)), data$targetsTrain, xlab = "x", ylab = "y", type = "p", col = "blue", pch = 1, cex = 1.5)
points(predictions, type = "p", col = "red", pch = 16)
# plot dados de teste
predictions <- predict(model, as.data.frame(data$inputsTest))
plot(seq(1, length(data$targetsTest)), data$targetsTest, xlab = "x", ylab = "y", type = "p", col = "blue", pch = 1, cex = 1.5)
points(predictions, type = "p", col = "red", pch = 16)
}
# Lista para armazenar os modelos treinados
trained_models <- list()
# Treinar e testar o modelo em uma janela deslizante de 10 em 10 com etapa de 1
for (i in 1:(nrow(x) - tam_janela + 1)) {
#cat("Testando janela", i, "até", i + tam_janela - 1, "\n")
model <- train_test_mlp(x, y, test_start = i, test_end = i + tam_janela - 1)
#summary(model)
trained_models[[length(trained_models) + 1]] <- model
}
# Função para fazer previsões com todos os modelos treinados
predict_all_models <- function(models, inputs) {
all_predictions <- c()
for (i in 1:length(models)) {
model <- models[[i]]
predictions <- predict(model, inputs[i:(i + tam_janela - 2), ])
all_predictions <- c(all_predictions, predictions[1])
}
return(all_predictions)
}
# Fazer previsões com todos os modelos treinados
all_predictions <- predict_all_models(trained_models, x)
# Plot da série temporal completa junto com as previsões
plot(seq(1, length(y)), y, xlab = "x", ylab = "y", type = "p", col = "blue", pch = 1, cex = 1.5)
points(seq(1, length(all_predictions)), all_predictions, type = "p", col = "red", pch = 16)
bd <- read.table("ibovespa_3.csv", header = TRUE, sep = ";")
x <- bd[, 1]
x <- normalizeData(x, type = "0_1")
tam_janela <- 10
nro_padroes <- trunc(dim(x)[1] / tam_janela)
dataset <- matrix(x, nrow = tam_janela, ncol = nro_padroes)
dataset <- t(dataset)
plot(dataset[, tam_janela])
# Column bind the data into one variable
x <- dataset[, 1:tam_janela - 1]
y <- dataset[, tam_janela]
# Função personalizada para dividir os dados de treinamento e teste com base no índice
split_data_by_index <- function(inputs, targets, test_indices) {
inputs_test <- inputs[test_indices,]
targets_test <- targets[test_indices]
inputs_train <- inputs[-test_indices,]
targets_train <- targets[-test_indices]
return(list(inputsTrain = inputs_train, targetsTrain = targets_train,
inputsTest = inputs_test, targetsTest = targets_test))
}
# Função para treinar e testar o modelo
train_test_mlp <- function(inputs, targets, test_start, test_end) {
data <- split_data_by_index(inputs, targets, test_indices = c(test_start:test_end))
model <- mlp(data$inputsTrain, data$targetsTrain,
size = c(2),
learnFuncParams = c(0.9),
maxit = 10,
learnFunc = "Std_Backpropagation",
hiddenActFunc = "Act_Logistic",
inputsTest = as.data.frame(data$inputsTest),
targetsTest = data$targetsTest,
linOut = TRUE
)
return(model)
}
# Função para plotar os resultados
plot_results <- function(model, data) {
# plot dados de treinamento
predictions <- predict(model, data$inputsTrain)
plot(seq(1, length(data$targetsTrain)), data$targetsTrain, xlab = "x", ylab = "y", type = "p", col = "blue", pch = 1, cex = 1.5)
points(predictions, type = "p", col = "red", pch = 16)
# plot dados de teste
predictions <- predict(model, as.data.frame(data$inputsTest))
plot(seq(1, length(data$targetsTest)), data$targetsTest, xlab = "x", ylab = "y", type = "p", col = "blue", pch = 1, cex = 1.5)
points(predictions, type = "p", col = "red", pch = 16)
}
# Lista para armazenar os modelos treinados
trained_models <- list()
# Treinar e testar o modelo em uma janela deslizante de 10 em 10 com etapa de 1
for (i in 1:(nrow(x) - tam_janela + 1)) {
#cat("Testando janela", i, "até", i + tam_janela - 1, "\n")
model <- train_test_mlp(x, y, test_start = i, test_end = i + tam_janela - 1)
#summary(model)
trained_models[[length(trained_models) + 1]] <- model
}
# Função para fazer previsões com todos os modelos treinados
predict_all_models <- function(models, inputs) {
all_predictions <- c()
for (i in 1:length(models)) {
model <- models[[i]]
predictions <- predict(model, inputs[i:(i + tam_janela - 2), ])
all_predictions <- c(all_predictions, predictions[1])
}
return(all_predictions)
}
# Fazer previsões com todos os modelos treinados
all_predictions <- predict_all_models(trained_models, x)
# Plot da série temporal completa junto com as previsões
plot(seq(1, length(y)), y, xlab = "x", ylab = "y", type = "p", col = "blue", pch = 1, cex = 1.5)
points(seq(1, length(all_predictions)), all_predictions, type = "p", col = "red", pch = 16)
bd <- read.table("ibovespa_3.csv", header = TRUE, sep = ";")
x <- bd[, 1]
x <- normalizeData(x, type = "0_1")
tam_janela <- 15
nro_padroes <- trunc(dim(x)[1] / tam_janela)
dataset <- matrix(x, nrow = tam_janela, ncol = nro_padroes)
dataset <- t(dataset)
plot(dataset[, tam_janela])
# Column bind the data into one variable
x <- dataset[, 1:tam_janela - 1]
y <- dataset[, tam_janela]
# Função personalizada para dividir os dados de treinamento e teste com base no índice
split_data_by_index <- function(inputs, targets, test_indices) {
inputs_test <- inputs[test_indices,]
targets_test <- targets[test_indices]
inputs_train <- inputs[-test_indices,]
targets_train <- targets[-test_indices]
return(list(inputsTrain = inputs_train, targetsTrain = targets_train,
inputsTest = inputs_test, targetsTest = targets_test))
}
# Função para treinar e testar o modelo
train_test_mlp <- function(inputs, targets, test_start, test_end) {
data <- split_data_by_index(inputs, targets, test_indices = c(test_start:test_end))
model <- mlp(data$inputsTrain, data$targetsTrain,
size = c(2),
learnFuncParams = c(0.9),
maxit = 100,
learnFunc = "Std_Backpropagation",
hiddenActFunc = "Act_Logistic",
inputsTest = as.data.frame(data$inputsTest),
targetsTest = data$targetsTest,
linOut = TRUE
)
return(model)
}
# Função para plotar os resultados
plot_results <- function(model, data) {
# plot dados de treinamento
predictions <- predict(model, data$inputsTrain)
plot(seq(1, length(data$targetsTrain)), data$targetsTrain, xlab = "x", ylab = "y", type = "p", col = "blue", pch = 1, cex = 1.5)
points(predictions, type = "p", col = "red", pch = 16)
# plot dados de teste
predictions <- predict(model, as.data.frame(data$inputsTest))
plot(seq(1, length(data$targetsTest)), data$targetsTest, xlab = "x", ylab = "y", type = "p", col = "blue", pch = 1, cex = 1.5)
points(predictions, type = "p", col = "red", pch = 16)
}
# Lista para armazenar os modelos treinados
trained_models <- list()
# Treinar e testar o modelo em uma janela deslizante de 10 em 10 com etapa de 1
for (i in 1:(nrow(x) - tam_janela + 1)) {
#cat("Testando janela", i, "até", i + tam_janela - 1, "\n")
model <- train_test_mlp(x, y, test_start = i, test_end = i + tam_janela - 1)
#summary(model)
trained_models[[length(trained_models) + 1]] <- model
}
# Função para fazer previsões com todos os modelos treinados
predict_all_models <- function(models, inputs) {
all_predictions <- c()
for (i in 1:length(models)) {
model <- models[[i]]
predictions <- predict(model, inputs[i:(i + tam_janela - 2), ])
all_predictions <- c(all_predictions, predictions[1])
}
return(all_predictions)
}
# Fazer previsões com todos os modelos treinados
all_predictions <- predict_all_models(trained_models, x)
# Plot da série temporal completa junto com as previsões
plot(seq(1, length(y)), y, xlab = "x", ylab = "y", type = "p", col = "blue", pch = 1, cex = 1.5)
points(seq(1, length(all_predictions)), all_predictions, type = "p", col = "red", pch = 16)
bd <- read.table("ibovespa_3.csv", header = TRUE, sep = ";")
x <- bd[, 1]
x <- normalizeData(x, type = "0_1")
tam_janela <- 20
nro_padroes <- trunc(dim(x)[1] / tam_janela)
dataset <- matrix(x, nrow = tam_janela, ncol = nro_padroes)
dataset <- t(dataset)
plot(dataset[, tam_janela])
# Column bind the data into one variable
x <- dataset[, 1:tam_janela - 1]
y <- dataset[, tam_janela]
# Função personalizada para dividir os dados de treinamento e teste com base no índice
split_data_by_index <- function(inputs, targets, test_indices) {
inputs_test <- inputs[test_indices,]
targets_test <- targets[test_indices]
inputs_train <- inputs[-test_indices,]
targets_train <- targets[-test_indices]
return(list(inputsTrain = inputs_train, targetsTrain = targets_train,
inputsTest = inputs_test, targetsTest = targets_test))
}
# Função para treinar e testar o modelo
train_test_mlp <- function(inputs, targets, test_start, test_end) {
data <- split_data_by_index(inputs, targets, test_indices = c(test_start:test_end))
model <- mlp(data$inputsTrain, data$targetsTrain,
size = c(2),
learnFuncParams = c(0.9),
maxit = 100,
learnFunc = "Std_Backpropagation",
hiddenActFunc = "Act_Logistic",
inputsTest = as.data.frame(data$inputsTest),
targetsTest = data$targetsTest,
linOut = TRUE
)
return(model)
}
# Função para plotar os resultados
plot_results <- function(model, data) {
# plot dados de treinamento
predictions <- predict(model, data$inputsTrain)
plot(seq(1, length(data$targetsTrain)), data$targetsTrain, xlab = "x", ylab = "y", type = "p", col = "blue", pch = 1, cex = 1.5)
points(predictions, type = "p", col = "red", pch = 16)
# plot dados de teste
predictions <- predict(model, as.data.frame(data$inputsTest))
plot(seq(1, length(data$targetsTest)), data$targetsTest, xlab = "x", ylab = "y", type = "p", col = "blue", pch = 1, cex = 1.5)
points(predictions, type = "p", col = "red", pch = 16)
}
# Lista para armazenar os modelos treinados
trained_models <- list()
# Treinar e testar o modelo em uma janela deslizante de 10 em 10 com etapa de 1
for (i in 1:(nrow(x) - tam_janela + 1)) {
#cat("Testando janela", i, "até", i + tam_janela - 1, "\n")
model <- train_test_mlp(x, y, test_start = i, test_end = i + tam_janela - 1)
#summary(model)
trained_models[[length(trained_models) + 1]] <- model
}
# Função para fazer previsões com todos os modelos treinados
predict_all_models <- function(models, inputs) {
all_predictions <- c()
for (i in 1:length(models)) {
model <- models[[i]]
predictions <- predict(model, inputs[i:(i + tam_janela - 2), ])
all_predictions <- c(all_predictions, predictions[1])
}
return(all_predictions)
}
# Fazer previsões com todos os modelos treinados
all_predictions <- predict_all_models(trained_models, x)
# Plot da série temporal completa junto com as previsões
plot(seq(1, length(y)), y, xlab = "x", ylab = "y", type = "p", col = "blue", pch = 1, cex = 1.5)
points(seq(1, length(all_predictions)), all_predictions, type = "p", col = "red", pch = 16)
#install.packages("RSNNS")
library("RSNNS")
bd <- read.table("ibovespa_3.csv", header = TRUE, sep = ";")
x <- bd[, 1]
x <- normalizeData(x, type = "0_1")
plot(x)
epoch <- 1000
bd <- read.table("ibovespa_3.csv", header = TRUE, sep = ";")
x <- bd[, 1]
x <- normalizeData(x, type = "0_1")
tam_janela <- 5
nro_padroes <- trunc(dim(x)[1] / tam_janela)
dataset <- matrix(x, nrow = tam_janela, ncol = nro_padroes)
dataset <- t(dataset)
plot(dataset[, tam_janela])
# Column bind the data into one variable
x <- dataset[, 1:tam_janela - 1]
y <- dataset[, tam_janela]
# Função personalizada para dividir os dados de treinamento e teste com base no índice
split_data_by_index <- function(inputs, targets, test_indices) {
inputs_test <- inputs[test_indices,]
targets_test <- targets[test_indices]
inputs_train <- inputs[-test_indices,]
targets_train <- targets[-test_indices]
return(list(inputsTrain = inputs_train, targetsTrain = targets_train,
inputsTest = inputs_test, targetsTest = targets_test))
}
# Função para treinar e testar o modelo
train_test_mlp <- function(inputs, targets, test_start, test_end) {
data <- split_data_by_index(inputs, targets, test_indices = c(test_start:test_end))
model <- mlp(data$inputsTrain, data$targetsTrain,
size = c(2),
learnFuncParams = c(0.9),
maxit = epoch,
learnFunc = "Std_Backpropagation",
hiddenActFunc = "Act_Logistic",
inputsTest = as.data.frame(data$inputsTest),
targetsTest = data$targetsTest,
linOut = TRUE
)
return(model)
}
# Função para plotar os resultados
plot_results <- function(model, data) {
# plot dados de treinamento
predictions <- predict(model, data$inputsTrain)
plot(seq(1, length(data$targetsTrain)), data$targetsTrain, xlab = "x", ylab = "y", type = "p", col = "blue", pch = 1, cex = 1.5)
points(predictions, type = "p", col = "red", pch = 16)
# plot dados de teste
predictions <- predict(model, as.data.frame(data$inputsTest))
plot(seq(1, length(data$targetsTest)), data$targetsTest, xlab = "x", ylab = "y", type = "p", col = "blue", pch = 1, cex = 1.5)
points(predictions, type = "p", col = "red", pch = 16)
}
# Lista para armazenar os modelos treinados
trained_models <- list()
# Treinar e testar o modelo em uma janela deslizante de 10 em 10 com etapa de 1
for (i in 1:(nrow(x) - tam_janela + 1)) {
#cat("Testando janela", i, "até", i + tam_janela - 1, "\n")
model <- train_test_mlp(x, y, test_start = i, test_end = i + tam_janela - 1)
#summary(model)
trained_models[[length(trained_models) + 1]] <- model
}
#install.packages("RSNNS")
library("RSNNS")
bd <- read.table("ibovespa_3.csv", header = TRUE, sep = ";")
x <- bd[, 1]
x <- normalizeData(x, type = "0_1")
plot(x)
epoch <- 10
#install.packages("RSNNS")
library("RSNNS")
bd <- read.table("ibovespa_3.csv", header = TRUE, sep = ";")
x <- bd[, 1]
x <- normalizeData(x, type = "0_1")
plot(x)
epoch <- 10
bd <- read.table("ibovespa_3.csv", header = TRUE, sep = ";")
x <- bd[, 1]
x <- normalizeData(x, type = "0_1")
tam_janela <- 5
nro_padroes <- trunc(dim(x)[1] / tam_janela)
dataset <- matrix(x, nrow = tam_janela, ncol = nro_padroes)
dataset <- t(dataset)
plot(dataset[, tam_janela])
# Column bind the data into one variable
x <- dataset[, 1:tam_janela - 1]
y <- dataset[, tam_janela]
# Função personalizada para dividir os dados de treinamento e teste com base no índice
split_data_by_index <- function(inputs, targets, test_indices) {
inputs_test <- inputs[test_indices,]
targets_test <- targets[test_indices]
inputs_train <- inputs[-test_indices,]
targets_train <- targets[-test_indices]
return(list(inputsTrain = inputs_train, targetsTrain = targets_train,
inputsTest = inputs_test, targetsTest = targets_test))
}
# Função para treinar e testar o modelo
train_test_mlp <- function(inputs, targets, test_start, test_end) {
data <- split_data_by_index(inputs, targets, test_indices = c(test_start:test_end))
model <- mlp(data$inputsTrain, data$targetsTrain,
size = c(2),
learnFuncParams = c(0.9),
maxit = epoch,
learnFunc = "Std_Backpropagation",
hiddenActFunc = "Act_Logistic",
inputsTest = as.data.frame(data$inputsTest),
targetsTest = data$targetsTest,
linOut = TRUE
)
return(model)
}
# Função para plotar os resultados
plot_results <- function(model, data) {
# plot dados de treinamento
predictions <- predict(model, data$inputsTrain)
plot(seq(1, length(data$targetsTrain)), data$targetsTrain, xlab = "x", ylab = "y", type = "p", col = "blue", pch = 1, cex = 1.5)
points(predictions, type = "p", col = "red", pch = 16)
# plot dados de teste
predictions <- predict(model, as.data.frame(data$inputsTest))
plot(seq(1, length(data$targetsTest)), data$targetsTest, xlab = "x", ylab = "y", type = "p", col = "blue", pch = 1, cex = 1.5)
points(predictions, type = "p", col = "red", pch = 16)
}
# Lista para armazenar os modelos treinados
trained_models <- list()
# Treinar e testar o modelo em uma janela deslizante de 10 em 10 com etapa de 1
for (i in 1:(nrow(x) - tam_janela + 1)) {
#cat("Testando janela", i, "até", i + tam_janela - 1, "\n")
model <- train_test_mlp(x, y, test_start = i, test_end = i + tam_janela - 1)
#summary(model)
trained_models[[length(trained_models) + 1]] <- model
}
# Função para fazer previsões com todos os modelos treinados
predict_all_models <- function(models, inputs) {
all_predictions <- c()
for (i in 1:length(models)) {
model <- models[[i]]
predictions <- predict(model, inputs[i:(i + tam_janela - 2), ])
all_predictions <- c(all_predictions, predictions[1])
}
return(all_predictions)
}
# Fazer previsões com todos os modelos treinados
all_predictions <- predict_all_models(trained_models, x)
# Plot da série temporal completa junto com as previsões
plot(seq(1, length(y)), y, xlab = "x", ylab = "y", type = "p", col = "blue", pch = 1, cex = 1.5)
points(seq(1, length(all_predictions)), all_predictions, type = "p", col = "red", pch = 16)
